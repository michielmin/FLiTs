c=========================================================================================
c This subroutine reads in a forFLiTs.fits file generated by ProDiMo
c It fills the arrays:
c dens,T,kabs,kext,ksca,v,lam_cont,R,Theta,Fstar,and the population levels
c=========================================================================================
	subroutine ReadForFLiTs()
	use GlobalSetup
	use Constants
	IMPLICIT NONE
	integer nvars,ivars,i,j,k,imol,l,naxis
	character*7 vars(10),hdu
	real*8,allocatable :: array(:,:,:,:)
	real*8,allocatable :: array_d(:,:,:,:)
	integer*4 :: status,stat2,stat3,readwrite,unit,blocksize,nfound,group
	integer*4 :: firstpix,nbuffer,npixels,hdunum,hdutype,ix,iz,ilam  
	integer*4 :: istat,stat4,tmp_int,stat5,stat6,idummy,Npop
      integer*8 :: npixelsll  ! this is for the ll (huge files) routines of cfitsio
      integer*8,parameter :: firstpixelll=1 
	real*8  :: nullval
	real*8  :: nullval_d,xx,zz,rr,tot,thetamax,rdummy
	logical*4 :: anynull
	integer*4, dimension(4) :: naxes
	character*80 comment,errmessage
	character*30 errtext
	integer*4, dimension(nmol) :: ispec
	integer*4 :: is
	logical :: exdat,found
	interface
	  subroutine output(string)
	  IMPLICIT NONE
	  character string*(*)
	  end

	  character*20 function int2string(i,form)
	  IMPLICIT NONE
	  integer i
	  character,intent(in),optional :: form*(*)
	  end

	  character*20 function dbl2string(x,form)
	  IMPLICIT NONE
	  real*8 x
	  character,intent(in),optional :: form*(*)
	  end

		subroutine fill_npop(imol,ipop_start,ipop_end,array)
			implicit none
			integer, intent(in) :: imol
			integer, intent(in) :: ipop_start,ipop_end
			real*8, intent(in) :: array(:,:,:,:)			
		end
	end interface

	! Use unformatted exchange file if present
	! FIXME: this is not used anymore, ProDiMo can only write the fits file now. 
	inquire(file="ProDiMoForFLiTs.dat",exist=exdat)
	
  	!------------------------------------------------------------------------
	! HDU0 : grid
	!------------------------------------------------------------------------
	if (exdat) then
	  open(unit=1,file="ProDiMoForFLiTs.dat",form="unformatted",status="old")
	  read(1) idummy 
	  read(1) Rin
	  read(1) Rout
	  read(1) Mstar
	  read(1) Rstar
	  read(1) rdummy
	  read(1) distance
	  read(1) rdummy
	  read(1) nR
	  read(1) nTheta
	  read(1) nspec
	  read(1) nlam
	else   
	  ! Get an unused Logical Unit Number to use to open the FITS file.
	  status=0
		call ftgiou (unit,status)
	  ! Open file
	  readwrite=0
	  call ftopen(unit,FLiTsfile,readwrite,blocksize,status)
	  if (status /= 0) then
	     write(*,'("forFLiTs file not found")')
	     write(9,'("forFLiTs file not found")')
	     print*,trim(FLiTsfile)
	     write(*,'("--------------------------------------------------------")')
	     write(9,'("--------------------------------------------------------")')
	     stop
	  endif
		call output("Reading forFLiTs file: "//trim(FLiTsfile)//" ...")
	  group=1
	  firstpix=1
	  nullval=-999
	  nullval_d=-999
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,3,naxes,nfound,status)
	  npixels=naxes(1)*naxes(2)*naxes(3)
	  ! Read model info
		call ftgkyd(unit,'Rin',Rin,comment,status)
		call ftgkyd(unit,'Rout',Rout,comment,status)
		call ftgkyd(unit,'Mstar',Mstar,comment,status)
		call ftgkyd(unit,'Rstar',Rstar,comment,status)
		call ftgkyd(unit,'distance',distance,comment,status)
		call ftgkyj(unit,'NXX',nR,comment,status)
		call ftgkyj(unit,'NZZ',nTheta,comment,status)
		call ftgkyj(unit,'NSPEC',nspec,comment,status)

		! potentially slow, but need to know all the species names. 
	  ! move to the population hdu
		allocate(mol_name0(nspec))
		call ftmahd(unit,13,hdutype,status) ! one HDU before the population data
	  do i=1,nspec
			! move to next hdu, do it at beginng of loop to avoid problems at the end
			call ftmrhd(unit,1,hdutype,status)
			call ftgkys(unit,'SPECIES',mol_name0(i),comment,status)
			if (status.ne.0) then
				write(*,*) "Error reading species name for imol=",i
				goto 1				
			endif
		end do
	  ! move back to the first hdu
	  call ftmahd(unit,1,hdutype,status) 
		if (status.ne.0) goto 1
    ! now build an index
		
		do imol=1,nmol
			! means that we have a molecule that is not in the FITS file
			! at least in contect with ProDiMo this should not happen (as there would be not lamda.dat file)
			ispec(imol)=-1 
      do i=nspec,1,-1
        if(trim(Mol(imol)%name).eq.trim(mol_name0(i))) then 					
					ispec(imol)=i
					exit
				endif
      enddo
		enddo
	endif

	nR=nR+1
	nTheta=nTheta+1

	allocate(C(0:nR,0:nTheta))
	allocate(R(0:nR+1))
	allocate(Theta(0:nR,0:nTheta+1))
	allocate(array(nR-1,nTheta-1,4,1))
	allocate(R_av(0:nR))
	allocate(theta_av(0:nR,0:nTheta))

	if (exdat) then
	  read(1) array 
	else   
  	  call ftgpvd(unit,group,firstpix,npixels,nullval,array,anynull,status)
	endif  

	Rin=array(1,1,1,1)/AU
	call output("Adjusting Rin to:  "//trim(dbl2string(Rin,'(f10.6)')) //" AU")
	Rout=array(nR-1,1,2,1)/AU
	call output("Adjusting Rout to: "//trim(dbl2string(Rout,'(f10.3)')) //" AU")

	R(0)=Rstar*Rsun
	do i=1,nR-1
	   R(i)=array(i,1,1,1)
	enddo
	R(nR)=array(nR-1,1,2,1)

	do i=1,nR-1
	   R_av(i)=sqrt(R(i)*R(i+1))
	enddo

        ! in the theta grid we actually store cos(theta) for convenience
	thetamax=0d0
	do i=1,nR-1
	   Theta(i,0)=1d0
	   do j=2,nTheta
	      Theta(i,j)=array(i,nTheta+1-j,4,1)/sqrt(R_av(i)**2+array(i,nTheta+1-j,4,1)**2)
	   enddo
	   Theta(i,nTheta+1)=0d0
	   Theta(i,1)=(Theta(i,0)+Theta(i,2))/2d0
	   
	   if (cylindrical) then
	      theta_av(i,0)=acos(Theta(i,1))/2d0
	   else
	      Theta(i,1)=1d0
	      theta_av(i,0)=0d0
	   endif
	   
	   do j=1,nTheta
	      theta_av(i,j)=acos((Theta(i,j)+Theta(i,j+1))/2d0)
	   enddo
	   if(Theta(i,2).gt.thetamax) thetamax=Theta(i,2)
	enddo
	Theta(1:nR-1,1)=(0.9*thetamax+0.1*Theta(1:nR-1,0))
	theta_av(1:nR-1,1)=acos((Theta(1:nR-1,1)+Theta(1:nR-1,2))/2d0)

	Theta(0,0:nTheta+1)=Theta(1,0:nTheta+1)
	theta_av(0,0:nTheta)=theta_av(1,0:nTheta)

	Theta(nR,0:nTheta+1)=Theta(nR-1,0:nTheta+1)
	theta_av(nR,0:nTheta)=theta_av(nR-1,0:nTheta)

	if (cylindrical) then
	   Rout=Rout*1.0001/sin(acos(Theta(nR,1)))
	else
	   Rout=Rout*1.0001
	endif

	R(nR+1)=Rout*AU

	R_av(nR-1)=sqrt(R(nR-1)*R(nR))
	R_av(nR)=sqrt(R(nR)*R(nR+1))

	call sort(R(1:nR+1),nR+1)

	allocate(R_sphere(0:nR+1))
	allocate(R_av_sphere(0:nR+1))
	if (cylindrical) then
	   do i=0,nR
	      R_sphere(i)=R(i)/sin(acos(Theta(i,1)))
	      R_av_sphere(i)=R_av(i)/sin(acos(Theta(i,1)))
	   enddo
	   R_sphere(nR+1)=R(nR+1)
	   R_av_sphere(nR)=sqrt(R_sphere(nR)*R_sphere(nR+1))
	else
	   do i=0,nR
	      R_sphere(i)=R(i)
	      R_av_sphere(i)=R_av(i)
	   enddo
	   R_sphere(nR+1)=R(nR+1)
	endif

	deallocate(array)

	do i=0,nR
	   do j=0,nTheta
	      allocate(C(i,j)%npop(nmol))
        ! TODO: check if it is okay to allocate it here, or if it should be allocated earlier
	      allocate(C(i,j)%N(nmol))
	      allocate(C(i,j)%line_width(nmol))
	   enddo
	enddo


  !------------------------------------------------------------------------------
	! HDU 1 : Gas Temperature 
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nR-1,nTheta-1,1,1))
	  read(1) array_d    ! read pointgrid
	  read(1) array_d
	else   
	  ! move to first image hdu
	  call ftmahd(unit,2,hdutype,status)
	  if (status.ne.0) then			
			!status=0
	    goto 1
	  endif
	  naxis=2
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      C(i,j)%Tgas=array_d(i,nTheta+1-j,1,1)
	      if(C(i,j)%Tgas.lt.1d0) C(i,j)%Tgas=1d0
	   enddo
	   C(i,1)%Tgas=C(i,2)%Tgas
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 2 : Dust Temperature 
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nR-1,nTheta-1,1,1))
	  read(1) array_d
	else  
  	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=2
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
  	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      C(i,j)%Tdust=array_d(i,nTheta+1-j,1,1)
	      if(C(i,j)%Tdust.lt.1d0) C(i,j)%Tdust=1d0
	   enddo
	   C(i,1)%Tdust=C(i,2)%Tdust
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 3 : Gas density [1/cm^3]
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nR-1,nTheta-1,1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=2
  	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	    naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
  	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      C(i,j)%dens=array_d(i,nTheta+1-j,1,1)*mp
	      if(C(i,j)%dens.lt.1d-50) C(i,j)%dens=1d-60
	   enddo
	   C(i,1)%dens=1d-60
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 4 : Lambda
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,1,1,1))
	  read(1) array_d
	else  
  	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=1
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  nlam=naxes(1)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
  	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=0,nR
	   do j=0,nTheta
	      allocate(C(i,j)%kabs(nlam))
	      allocate(C(i,j)%albedo(nlam))
	      allocate(C(i,j)%kext(nlam))
	      allocate(C(i,j)%LRF(nlam))
	      allocate(C(i,j)%S(nlam))
	   enddo
	enddo

 	allocate(lam_cont(nlam))
 	allocate(Fstar(nlam))
 
	do i=1,nlam
	   lam_cont(i)=array_d(i,1,1,1)*1d4
	enddo

	if (lam_cont(1).gt.lmin) then
	   if (lam_cont(1).gt.lmax) then
	      call output("Wavelength interval not in FLiTs file")
	      stop
	   endif
	   lmin=lam_cont(1)
	   call output("Adjusting lambda_min to " //trim(dbl2string(lmin,'(f10.4)')))
	endif

	if (lam_cont(nlam).lt.lmax) then
	   if (lam_cont(nlam).lt.lmin) then
	      call output("Wavelength interval not in FLiTs file")
	      stop
	   endif
	   lmax=lam_cont(nlam)
	   call output("Adjusting lambda_max to " //trim(dbl2string(lmax,'(f10.4)')))
	endif

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 5 : Star spectrum
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,1,1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=1
  	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
  	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nlam
	   Fstar(i)=array_d(i,1,1,1)
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 6 : ISM spectrum
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,1,1,1))
	  read(1) array_d
	  deallocate(array_d)
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	    status=0
	    goto 1
	  endif
	  ! IISM is unused!!!
	endif  


	!------------------------------------------------------------------------------
	! HDU 7 : Opacites (abs)
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
  	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=4
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      do l=1,nlam
		 C(i,j)%kabs(l)=array_d(l,i,nTheta+1-j,1)
	      enddo
	   enddo
	   C(i,1)%kabs(1:nlam)=C(i,2)%kabs(1:nlam)/1d20
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 8 : Opacites (ext)
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=4
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif
  
	do i=1,nR-1
	   do j=2,nTheta
	      do l=1,nlam
		 C(i,j)%kext(l)=array_d(l,i,nTheta+1-j,1)
		 if(C(i,j)%kext(l).gt.1d-150) then
		    C(i,j)%albedo(l)=(C(i,j)%kext(l)-C(i,j)%kabs(l))/C(i,j)%kext(l)
		 else
		    C(i,j)%albedo(l)=0.5d0
		 endif
	      enddo
	   enddo
	   C(i,1)%kext(1:nlam)=C(i,2)%kext(1:nlam)/1d20
	   C(i,1)%albedo(1:nlam)=C(i,2)%albedo(1:nlam)
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 9 : Internal field
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=3
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      do l=1,nlam
		 C(i,j)%LRF(l)=array_d(l,i,nTheta+1-j,1)
c                C(i,j)%LRF(l)=C(i,j)%LRF(l)*lam_cont(l)*1d3*1d-4/clight
	      enddo
	   enddo
	   C(i,1)%LRF(1:nlam)=C(i,2)%LRF(1:nlam)/1d20
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 10 : Source function
	!------------------------------------------------------------------------------
	if (exdat) then
	  allocate(array_d(nlam,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=3
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	   do j=2,nTheta
	      do l=1,nlam
		 C(i,j)%S(l)=exp(array_d(l,i,nTheta+1-j,1))
	      enddo
	   enddo
	   C(i,1)%S(1:nlam)=C(i,2)%S(1:nlam)/1d20
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 11 : Molecular particle densities [1/cm^3]
	!------------------------------------------------------------------------------
	! TODO: similar to the pops also here N0 is just a temporary array
	if (exdat) then
	  allocate(array_d(nspec,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=3
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
	  do j=2,nTheta    ! FIXME: that will not work, if it is not a fits file.
	    do imol=1,nmol ! fill only the molecules we need				
		 		C(i,j)%N(imol)=array_d(ispec(imol),i,nTheta+1-j,1)
	    enddo
	  enddo
		C(i,1)%N(1:nmol)=C(i,2)%N(1:nmol)/1d20
	enddo

	deallocate(array_d)


	!------------------------------------------------------------------------------
	! HDU 12 : Line broadening parameter
	!------------------------------------------------------------------------------
	! TODO: also here line_width0 is just a temporary array
	if (exdat) then
	  allocate(array_d(nspec,nR-1,nTheta-1,1))
	  read(1) array_d
	else  
	  ! move to next hdu
	  call ftmrhd(unit,1,hdutype,status)
	  if (status.ne.0) then
	     status=0
	     goto 1
	  endif
	  naxis=3
	  ! Check dimensions
	  call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  do i=naxis+1,4
	     naxes(i)=1
	  enddo
	  npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)
	  ! read_image
	  allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)
	endif  

	do i=1,nR-1
		do j=2,nTheta
	  	do imol=1,nmol
				C(i,j)%line_width(imol)=array_d(ispec(imol),i,nTheta+1-j,1)
	    enddo
	  enddo
	  C(i,1)%line_width(1:nmol)=C(i,2)%line_width(1:nmol)/1d20
	enddo

	deallocate(array_d)
	

	!------------------------------------------------------------------------------
	! HDU 13... : relative level populations
	!------------------------------------------------------------------------------	
	
	do is=1,nspec
		! find the imol that belongs to is
		found=.false.
		do imol=1,nmol
			if (ispec(imol)==is) then 
				found=.true.
				exit
			endif
		enddo 

	if (exdat) then
      read(1) mol_name0(is)
      read(1) Npop
      allocate(array_d(Npop,nR-1,nTheta-1,1))
			! always need to read, but if we do not need it we skip it
      read(1) array_d
		if (.not.found) then ! ispec is not in the list of the imol ... so do not need it
			call output(int2string(is,'(i3)')//"Skipping "//trim(mol_name0(is))//" in FLiTs file.")
			deallocate(array_d)
			cycle
		endif
	else
	  	! move to next hdu, always need to move 
	  	call ftmrhd(unit,1,hdutype,status)
	  	if (status.ne.0) then ! if we get an error here, we assume we reached the end of file
	    	status=0 ! to not have an error message
	    	goto 1
	  	endif

		if (.not.found) then ! ispec is not in the list of the imol ... so do not need it
        call output(int2string(is,'(i3)')//"Skipping " // trim(mol_name0(is)) // " in FLiTs file.")
        cycle
      endif

      naxis=3
      ! Check dimensions
	  	call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)
	  	call ftgkyj(unit,'NLEV',Npop,comment,status)
 	  	do i=naxis+1,4
	    	naxes(i)=1
	  	enddo
    	! just to be absolutely sure that npixels8 stays integer*8
		npixelsll=INT(1,kind(npixelsll))
		do i=1,naxis
			npixelsll=npixelsll*naxes(i)
		enddo
	  	allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))
	  	call ftgpvdll(unit,group,firstpixelll,npixelsll,nullval_d,array_d,anynull,status)
    	! check for errors
			if (status.ne.0) goto 1
		endif
		call output(int2string(is,'(i3)') // "Found " // trim(mol_name0(is)) // " in FLiTs file")	

		! imol was already initialised properly
		call alloc_npop(imol,Npop)
		call fill_npop(imol,1,Npop,array_d)
		deallocate(array_d)
	enddo ! NSPEC loop

1     continue
	if (.not.exdat) then
	   ! Close the file and free the unit number.
	   call ftclos(unit, status)
		call ftfiou(unit, status)
		!  Check for any error, and if so print out error messages
		!  Get the text string which describes the error
		if (status > 0) then
			call ftgerr(status,errtext)
			print *,'FITSIO Error Status =',status,': ',errtext
			!  Read and print out all the error messages on the FITSIO stack		 
			call ftgmsg(errmessage)
			do while (errmessage .ne. ' ')
				print *,errmessage
				call ftgmsg(errmessage)				
			end do
		stop ! We got an error, so better to stop everything
	endif
	endif
	
	do i=1,nR-1
	   do j=1,nTheta
	      xx=R_av(i)
	      zz=xx/tan(theta_av(i,j))
	      rr=sqrt(xx*xx+zz*zz)
	      C(i,j)%v=sqrt(G*Mstar*Msun*xx*xx/(rr*rr*rr))
	   enddo
	enddo
	i=0
	do j=0,nTheta
	   C(i,j)%kext(1:nlam)=1d-70
	   C(i,j)%kabs(1:nlam)=1d-70
	   xx=R_av(1)
	   zz=xx/tan(theta_av(i,j))
	   rr=sqrt(xx*xx+zz*zz)
	   C(i,j)%v=sqrt(G*Mstar*Msun*xx*xx/(rr*rr*rr))
	   C(i,j)%dens=1d-60
	enddo
	i=nR
	do j=0,nTheta
	   C(i,j)%kext(1:nlam)=1d-70
	   C(i,j)%kabs(1:nlam)=1d-70
	   xx=R_av(i)
	   zz=xx/tan(theta_av(i,j))
	   rr=sqrt(xx*xx+zz*zz)
	   C(i,j)%v=sqrt(G*Mstar*Msun*xx*xx/(rr*rr*rr))
	   C(i,j)%dens=1d-60
	enddo

	j=0
	do i=1,nR
	   C(i,j)%kext(1:nlam)=1d-70
	   C(i,j)%kabs(1:nlam)=1d-70
	   xx=R_av(i)
	   zz=xx/tan(theta_av(i,j))
	   rr=sqrt(xx*xx+zz*zz)
	   C(i,j)%v=sqrt(G*Mstar*Msun*xx*xx/(rr*rr*rr))
	   C(i,j)%dens=1d-60
	enddo
	
	return
	
	end
	
	subroutine alloc_npop(imol,Npop)
		! This subroutine allocates the whole npop0 array for one molecule
		use GlobalSetup, only: C,nR,nTheta
		implicit none
		integer, intent(in) :: imol
		integer, intent(in) :: Npop
		integer :: i,j
		do i=0,nR
	  	do j=0,nTheta
	    	allocate(C(i,j)%npop(imol)%N(Npop))
	  	enddo
		enddo
	end subroutine alloc_npop

	subroutine fill_npop(imol,ipop_start,ipop_end,array)
  		! This subroutine fill the npop array, from ipop_start to ipop_end
		! The array has dimension (ipop_end-ipop_start,nR,nTheta,1)
		use GlobalSetup, only: C, mol_name0, nR,nTheta
		implicit none
		integer, intent(in) :: imol
		integer, intent(in) :: ipop_start,ipop_end
		real*8, intent(in) :: array(:,:,:,:)
		integer :: i,j,k
		do i=1,nR-1
			do j=2,nTheta
				C(i,j)%npop(imol)%N=0d0
				do k=ipop_start,ipop_end
					C(i,j)%npop(imol)%N(k)=array((k-ipop_start)+1,i,nTheta+1-j,1)
				enddo
			enddo
			do k=ipop_start,ipop_end
				C(i,1)%npop(imol)%N(k)=C(i,2)%npop(imol)%N(k)
			enddo
		enddo		
	end subroutine fill_npop


